# Touwaka Mate V2 æ”¹è¿›å»ºè®®æŠ¥å‘Š

åŸºäºå¯¹ NanoClawã€OpenClawã€PicoClawã€ZeroClaw å››ä¸ªå¼€æºé¡¹ç›®çš„æ·±åº¦åˆ†æï¼Œç»“åˆå½“å‰é¡¹ç›®æ¶æ„ï¼Œæå‡ºä»¥ä¸‹å¯è½åœ°çš„æ”¹è¿›å»ºè®®ã€‚

---

## å½“å‰é¡¹ç›®æ¶æ„æ¦‚è§ˆ

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Expert Instance (Node.js)                     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚
â”‚  â”‚  Expressive â”‚â—„â”€â”€â–ºâ”‚  Reflective â”‚    â”‚   Memory    â”‚          â”‚
â”‚  â”‚    Mind     â”‚    â”‚    Mind     â”‚    â”‚   System    â”‚          â”‚
â”‚  â”‚(DeepSeek)   â”‚    â”‚(GLM-4-Flash)â”‚    â”‚  (MariaDB)  â”‚          â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜          â”‚
â”‚         â”‚                                      â”‚                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”‚                  â”‚
â”‚  â”‚ ToolManager â”‚â—„â”€â”€â–ºâ”‚  ContextManager  â”‚â—„â”€â”€â”€â”€â”€â”˜                  â”‚
â”‚  â”‚  (Skills)   â”‚    â”‚(Soul+InnerVoice) â”‚                           â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**æ ¸å¿ƒç‰¹ç‚¹ï¼š**
- äºŒåˆ†å¿ƒæ™ºæ¶æ„ï¼ˆè¡¨è¾¾+åæ€åŒæ¨¡å‹ï¼‰
- åŸºäºTopicçš„æ¶ˆæ¯å½’æ¡£
- Soul/InnerVoiceé©±åŠ¨çš„ä¸Šä¸‹æ–‡ç®¡ç†
- æ•°æ®åº“+æ–‡ä»¶ç³»ç»ŸåŒæ¨¡å¼æŠ€èƒ½å­˜å‚¨

---

## ä¸€ã€è®°å¿†ç³»ç»Ÿæ”¹è¿›å»ºè®®

### 1.1 å¼•å…¥å‘é‡æ£€ç´¢ï¼ˆå€Ÿé‰´ ZeroClawï¼‰

**ç°çŠ¶é—®é¢˜ï¼š**
- å½“å‰TopicåŒ¹é…åŸºäºLLMåˆ¤æ–­ï¼Œæˆæœ¬é«˜ä¸”æ…¢
- æ²¡æœ‰è¯­ä¹‰ç›¸ä¼¼åº¦æœç´¢èƒ½åŠ›

**æ”¹è¿›æ–¹æ¡ˆï¼š**
```javascript
// lib/vector-memory.js - æ–°å¢å‘é‡è®°å¿†å±‚
class VectorMemory {
  constructor(db, embeddingProvider) {
    this.db = db;
    this.embedder = embeddingProvider; // æ”¯æŒæœ¬åœ°æˆ–API embedding
  }

  async store(key, content, category = 'conversation') {
    // 1. ç”Ÿæˆembeddingï¼ˆä½¿ç”¨è½»é‡çº§æ¨¡å‹å¦‚ BGE-smallï¼‰
    const embedding = await this.embedder.embed(content);
    
    // 2. å­˜å…¥æ•°æ®åº“ï¼ˆæ–°å¢ embeddings è¡¨ï¼‰
    await this.db.execute(
      `INSERT INTO memory_vectors (key, content, category, embedding) 
       VALUES (?, ?, ?, ?)`,
      [key, content, category, JSON.stringify(embedding)]
    );
  }

  async recall(query, limit = 5) {
    // 1. ç”ŸæˆæŸ¥è¯¢embedding
    const queryEmbedding = await this.embedder.embed(query);
    
    // 2. å‘é‡ç›¸ä¼¼åº¦æœç´¢ï¼ˆä½™å¼¦ç›¸ä¼¼åº¦ï¼‰
    const results = await this.db.query(
      `SELECT key, content, category,
              cosine_similarity(embedding, ?) as score
       FROM memory_vectors
       ORDER BY score DESC
       LIMIT ?`,
      [JSON.stringify(queryEmbedding), limit]
    );
    
    return results;
  }
}
```

**æ•°æ®åº“è¡¨è®¾è®¡ï¼š**
```sql
CREATE TABLE memory_vectors (
  id INT AUTO_INCREMENT PRIMARY KEY,
  expert_id VARCHAR(64) NOT NULL,
  contact_id VARCHAR(64),
  key_name VARCHAR(255) NOT NULL,
  content TEXT NOT NULL,
  category ENUM('core', 'daily', 'conversation', 'topic') DEFAULT 'conversation',
  embedding JSON NOT NULL, -- å­˜å‚¨å‘é‡æ•°ç»„
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  INDEX idx_expert_category (expert_id, category),
  FULLTEXT INDEX ft_content (content) -- æ··åˆæœç´¢å¤‡ç”¨
);
```

**ä¼˜å…ˆçº§ï¼š** â­â­â­â­â­
**å·¥ä½œé‡ï¼š** ä¸­ç­‰ï¼ˆ2-3å¤©ï¼‰
**æ”¶ç›Šï¼š** TopicåŒ¹é…å‡†ç¡®ç‡æå‡50%+ï¼Œå“åº”å»¶è¿Ÿé™ä½

---

### 1.2 æ··åˆæœç´¢ç­–ç•¥ï¼ˆFTS5 + å‘é‡ï¼‰

**å€Ÿé‰´ ZeroClaw çš„æ··åˆæ£€ç´¢ï¼š**
```javascript
// lib/hybrid-search.js
class HybridSearch {
  async search(query, options = {}) {
    const { vectorWeight = 0.7, keywordWeight = 0.3, limit = 10 } = options;
    
    // å¹¶è¡Œæ‰§è¡Œä¸¤ç§æœç´¢
    const [vectorResults, keywordResults] = await Promise.all([
      this.vectorSearch(query, limit * 2),
      this.keywordSearch(query, limit * 2)
    ]);
    
    // åŠ æƒèåˆ
    return this.mergeResults(vectorResults, keywordResults, vectorWeight, keywordWeight, limit);
  }
  
  mergeResults(vectorResults, keywordResults, vWeight, kWeight, limit) {
    const scores = new Map();
    
    // å½’ä¸€åŒ–å‘é‡åˆ†æ•°ï¼ˆä½™å¼¦ç›¸ä¼¼åº¦é€šå¸¸åœ¨0-1ä¹‹é—´ï¼‰
    vectorResults.forEach((r, i) => {
      scores.set(r.id, { ...r, score: (r.similarity || 0) * vWeight });
    });
    
    // å½’ä¸€åŒ–å…³é”®è¯åˆ†æ•°ï¼ˆBM25é£æ ¼ï¼‰
    keywordResults.forEach((r, i) => {
      const existing = scores.get(r.id);
      const keywordScore = (1 / (i + 1)) * kWeight; // æ’åå€’æ•°åŠ æƒ
      if (existing) {
        existing.score += keywordScore;
      } else {
        scores.set(r.id, { ...r, score: keywordScore });
      }
    });
    
    return Array.from(scores.values())
      .sort((a, b) => b.score - a.score)
      .slice(0, limit);
  }
}
```

**ä¼˜å…ˆçº§ï¼š** â­â­â­â­
**å·¥ä½œé‡ï¼š** ä¸­ç­‰ï¼ˆ1-2å¤©ï¼‰

---

### 1.3 Embeddingç¼“å­˜æœºåˆ¶

**å€Ÿé‰´ ZeroClaw çš„LRUç¼“å­˜ï¼š**
```javascript
// lib/embedding-cache.js
class EmbeddingCache {
  constructor(maxSize = 10000) {
    this.cache = new Map();
    this.maxSize = maxSize;
    this.accessOrder = []; // LRUè¿½è¸ª
  }

  async getOrCompute(content, computeFn) {
    const hash = this.hashContent(content);
    
    if (this.cache.has(hash)) {
      this.updateLRU(hash);
      return this.cache.get(hash);
    }
    
    const embedding = await computeFn(content);
    this.set(hash, embedding);
    return embedding;
  }
  
  hashContent(content) {
    // ä½¿ç”¨ SHA-256 å‰8å­—èŠ‚ä½œä¸ºå“ˆå¸Œ
    return crypto.createHash('sha256').update(content).digest('hex').slice(0, 16);
  }
}
```

**ä¼˜å…ˆçº§ï¼š** â­â­â­
**å·¥ä½œé‡ï¼š** å°ï¼ˆåŠå¤©ï¼‰

---

## äºŒã€Skillç³»ç»Ÿæ”¹è¿›å»ºè®®

### 2.1 TOMLå£°æ˜å¼æŠ€èƒ½å®šä¹‰ï¼ˆå€Ÿé‰´ ZeroClawï¼‰

**ç°çŠ¶é—®é¢˜ï¼š**
- å½“å‰æŠ€èƒ½éœ€è¦å†™JavaScriptä»£ç ï¼Œé—¨æ§›é«˜
- ç®€å•å·¥å…·ï¼ˆå¦‚HTTPè°ƒç”¨ã€Shellå‘½ä»¤ï¼‰ä¹Ÿéœ€è¦å®Œæ•´æŠ€èƒ½æ–‡ä»¶

**æ”¹è¿›æ–¹æ¡ˆï¼š**
```toml
# skills/weather/SKILL.toml
[skill]
name = "weather"
description = "è·å–å¤©æ°”é¢„æŠ¥"
version = "1.0.0"
author = "touwaka"
tags = ["utility", "weather"]

[[tools]]
name = "get_weather"
description = "è·å–æŒ‡å®šåŸå¸‚çš„å¤©æ°”é¢„æŠ¥"
kind = "http"  # shell, http, script
command = "https://api.weather.com/v1/current"
method = "GET"
headers = { "Authorization" = "Bearer {{env.WEATHER_API_KEY}}" }

[tools.params]
city = { type = "string", required = true, description = "åŸå¸‚åç§°" }
units = { type = "string", enum = ["celsius", "fahrenheit"], default = "celsius" }

[[tools]]
name = "save_location"
description = "ä¿å­˜ç”¨æˆ·å¸¸ç”¨ä½ç½®"
kind = "memory"  # ç‰¹æ®Šç±»å‹ï¼šç›´æ¥å†™å…¥è®°å¿†ç³»ç»Ÿ
key_pattern = "user.locations.{{contactId}}"
```

**åŠ è½½å™¨å®ç°ï¼š**
```javascript
// lib/toml-skill-loader.js
class TomlSkillLoader {
  async loadFromToml(tomlPath) {
    const content = fs.readFileSync(tomlPath, 'utf-8');
    const manifest = toml.parse(content);
    
    // åŠ¨æ€ç”ŸæˆæŠ€èƒ½æ¨¡å—
    return {
      id: manifest.skill.name,
      ...manifest.skill,
      getTools: () => manifest.tools.map(t => this.convertToOpenAIFormat(t)),
      execute: (toolName, params, context) => this.executeTool(manifest, toolName, params, context)
    };
  }
  
  executeTool(manifest, toolName, params, context) {
    const tool = manifest.tools.find(t => t.name === toolName);
    
    switch (tool.kind) {
      case 'http':
        return this.executeHttpTool(tool, params);
      case 'shell':
        return this.executeShellTool(tool, params, context);
      case 'memory':
        return this.executeMemoryTool(tool, params, context);
      default:
        throw new Error(`Unknown tool kind: ${tool.kind}`);
    }
  }
}
```

**ä¼˜å…ˆçº§ï¼š** â­â­â­â­â­
**å·¥ä½œé‡ï¼š** ä¸­ç­‰ï¼ˆ2-3å¤©ï¼‰
**æ”¶ç›Šï¼š** æŠ€èƒ½å¼€å‘é—¨æ§›å¤§å¹…é™ä½ï¼Œéå¼€å‘è€…ä¹Ÿèƒ½åˆ›å»ºç®€å•æŠ€èƒ½

---

### 2.2 æŠ€èƒ½å¸‚åœºç”Ÿæ€ï¼ˆå€Ÿé‰´ ZeroClaw open-skillsï¼‰

**è®¾è®¡æ–¹æ¡ˆï¼š**
```javascript
// lib/skill-marketplace.js
class SkillMarketplace {
  constructor(repoUrl = 'https://github.com/besoeasy/open-skills') {
    this.repoUrl = repoUrl;
    this.localPath = path.join(os.homedir(), '.touwaka', 'skills-marketplace');
  }

  async sync() {
    if (!fs.existsSync(this.localPath)) {
      // é¦–æ¬¡å…‹éš†
      await exec(`git clone --depth 1 ${this.repoUrl} ${this.localPath}`);
    } else if (this.shouldSync()) {
      // æ¯å‘¨æ›´æ–°
      await exec(`git -C ${this.localPath} pull --ff-only`);
    }
  }
  
  async search(keyword) {
    const skills = await this.scanSkills();
    return skills.filter(s => 
      s.name.includes(keyword) || 
      s.tags.some(t => t.includes(keyword))
    );
  }
  
  async install(skillName) {
    const sourcePath = path.join(this.localPath, skillName);
    const targetPath = path.join(this.localSkillsPath, skillName);
    
    // æ”¯æŒ symlink æˆ– copy
    fs.symlinkSync(sourcePath, targetPath);
  }
}
```

**CLIæ”¯æŒï¼š**
```bash
# æœç´¢æŠ€èƒ½
npm run skill:search weather

# å®‰è£…æŠ€èƒ½
npm run skill:install weather

# åˆ—å‡ºå·²å®‰è£…
npm run skill:list

# æ›´æ–°æ‰€æœ‰æŠ€èƒ½
npm run skill:update
```

**ä¼˜å…ˆçº§ï¼š** â­â­â­â­
**å·¥ä½œé‡ï¼š** ä¸­ç­‰ï¼ˆ2å¤©ï¼‰

---

## ä¸‰ã€MCPå¯¹æ¥æ”¹è¿›å»ºè®®

### 3.1 MCPå·¥å…·æ¡¥æ¥å±‚ï¼ˆå€Ÿé‰´ OpenClawï¼‰

**ç°çŠ¶é—®é¢˜ï¼š**
- å½“å‰å·¥å…·ä»…é™äºå†…éƒ¨æŠ€èƒ½ç³»ç»Ÿ
- æ— æ³•åˆ©ç”¨å¤–éƒ¨MCPæœåŠ¡ï¼ˆå¦‚Composioçš„900+å·¥å…·ï¼‰

**æ”¹è¿›æ–¹æ¡ˆï¼š**
```javascript
// lib/mcp-adapter.js
class MCPAdapter {
  constructor(mcpServerUrl) {
    this.serverUrl = mcpServerUrl;
    this.tools = [];
  }

  async connect() {
    // è¿æ¥åˆ°MCPæœåŠ¡å™¨
    const response = await fetch(`${this.serverUrl}/tools`);
    const toolSpecs = await response.json();
    
    // è½¬æ¢ä¸ºOpenAIæ ¼å¼
    this.tools = toolSpecs.map(spec => this.convertToOpenAIFormat(spec));
  }
  
  async execute(toolName, params) {
    const response = await fetch(`${this.serverUrl}/execute`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ tool: toolName, params })
    });
    return response.json();
  }
  
  getToolDefinitions() {
    return this.tools;
  }
}

// é›†æˆåˆ° ToolManager
class ToolManager {
  async initialize() {
    // 1. åŠ è½½å†…éƒ¨æŠ€èƒ½
    await this.loadInternalSkills();
    
    // 2. è¿æ¥MCPæœåŠ¡ï¼ˆå¦‚æœé…ç½®äº†ï¼‰
    if (process.env.MCP_SERVER_URL) {
      this.mcpAdapter = new MCPAdapter(process.env.MCP_SERVER_URL);
      await this.mcpAdapter.connect();
    }
  }
  
  getToolDefinitions() {
    const internalTools = Array.from(this.skills.values()).flatMap(...);
    const mcpTools = this.mcpAdapter?.getToolDefinitions() || [];
    return [...internalTools, ...mcpTools];
  }
}
```

**é…ç½®ç¤ºä¾‹ï¼š**
```json
// config/mcp.json
{
  "adapters": [
    {
      "name": "composio",
      "type": "composio",
      "apiKey": "${COMPOSIO_API_KEY}"
    },
    {
      "name": "local-mcp",
      "type": "sse",
      "url": "http://localhost:3001"
    }
  ]
}
```

**ä¼˜å…ˆçº§ï¼š** â­â­â­â­â­
**å·¥ä½œé‡ï¼š** ä¸­ç­‰ï¼ˆ2-3å¤©ï¼‰
**æ”¶ç›Šï¼š** ç¬é—´è·å¾—æ•°ç™¾ä¸ªå¤–éƒ¨å·¥å…·èƒ½åŠ›

---

## å››ã€æ¶ˆæ¯ç³»ç»Ÿæ”¹è¿›å»ºè®®

### 4.1 å¤šé€šé“æ”¯æŒæ¶æ„ï¼ˆå€Ÿé‰´ OpenClawï¼‰

**ç°çŠ¶é—®é¢˜ï¼š**
- å½“å‰ä»…æ”¯æŒHTTP API
- æ— åŸç”Ÿå¾®ä¿¡ã€Telegramç­‰é›†æˆ

**æ”¹è¿›æ–¹æ¡ˆï¼š**
```javascript
// channels/channel-interface.js
class ChannelInterface {
  async initialize(config) {}
  async start(handler) {}  // handler: (message) => Promise<reply>
  async stop() {}
  async send(recipient, content) {}
  async broadcast(content) {}
}

// channels/wechat-channel.js
class WeChatChannel extends ChannelInterface {
  async initialize(config) {
    this.bot = new Wechaty({ puppet: config.puppet });
    
    this.bot.on('message', async (msg) => {
      const result = await this.messageHandler({
        contactId: msg.talker().id,
        content: msg.text(),
        channel: 'wechat'
      });
      
      await msg.say(result.response);
    });
  }
}

// channels/telegram-channel.js
class TelegramChannel extends ChannelInterface {
  async initialize(config) {
    this.bot = new Telegraf(config.token);
    
    this.bot.on('text', async (ctx) => {
      const result = await this.messageHandler({
        contactId: ctx.from.id.toString(),
        content: ctx.message.text,
        channel: 'telegram'
      });
      
      await ctx.reply(result.response);
    });
  }
}
```

**é€šé“ç®¡ç†å™¨ï¼š**
```javascript
// lib/channel-manager.js
class ChannelManager {
  constructor(expertInstance) {
    this.expert = expertInstance;
    this.channels = new Map();
  }

  async registerChannel(name, channel) {
    channel.setMessageHandler(this.handleMessage.bind(this));
    await channel.initialize(this.getConfig(name));
    this.channels.set(name, channel);
  }
  
  async handleMessage({ contactId, content, channel }) {
    // ç»Ÿä¸€åŒ…è£…contactIdï¼ŒåŒ…å«é€šé“ä¿¡æ¯
    const wrappedContactId = `${channel}:${contactId}`;
    return this.expert.handleMessage(wrappedContactId, content);
  }
}
```

**ä¼˜å…ˆçº§ï¼š** â­â­â­â­â­
**å·¥ä½œé‡ï¼š** è¾ƒå¤§ï¼ˆ5-7å¤©ï¼Œæ¯ä¸ªé€šé“1-2å¤©ï¼‰
**æ”¶ç›Šï¼š** å¤§å¹…æ‰©å±•ç”¨æˆ·è§¦è¾¾æ¸ é“

---

### 4.2 æ¶ˆæ¯é˜Ÿåˆ—ä¸æµæ§ï¼ˆå€Ÿé‰´ NanoClawï¼‰

**æ”¹è¿›æ–¹æ¡ˆï¼š**
```javascript
// lib/message-queue.js
class MessageQueue {
  constructor() {
    this.queues = new Map(); // contactId -> queue
    this.processing = new Set();
    this.maxConcurrent = 5;
  }

  async enqueue(contactId, message) {
    if (!this.queues.has(contactId)) {
      this.queues.set(contactId, []);
    }
    
    this.queues.get(contactId).push(message);
    this.processNext(contactId);
  }
  
  async processNext(contactId) {
    if (this.processing.has(contactId)) return;
    
    const queue = this.queues.get(contactId);
    if (!queue || queue.length === 0) return;
    
    this.processing.add(contactId);
    const message = queue.shift();
    
    try {
      await this.processMessage(contactId, message);
    } finally {
      this.processing.delete(contactId);
      // ç»§ç»­å¤„ç†ä¸‹ä¸€æ¡
      if (queue.length > 0) {
        setImmediate(() => this.processNext(contactId));
      }
    }
  }
}
```

**ä¼˜å…ˆçº§ï¼š** â­â­â­
**å·¥ä½œé‡ï¼š** å°ï¼ˆ1å¤©ï¼‰

---

## äº”ã€ç”¨æˆ·ç•Œé¢æ”¹è¿›å»ºè®®

### 5.1 CLIä½“éªŒä¼˜åŒ–ï¼ˆå€Ÿé‰´ ZeroClawï¼‰

**æ”¹è¿›æ–¹æ¡ˆï¼š**
```javascript
// ä½¿ç”¨ @clack/prompts ç¾åŒ–äº¤äº’
const { select, text, confirm } = require('@clack/prompts');

// cli/commands/interactive.js
async function interactiveMode(expert) {
  console.log(pc.green('â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—'));
  console.log(pc.green('â•‘     Touwaka Expert Chat v2       â•‘'));
  console.log(pc.green('â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•'));
  
  while (true) {
    const action = await select({
      message: 'é€‰æ‹©æ“ä½œ',
      options: [
        { value: 'chat', label: 'ğŸ’¬ å¼€å§‹å¯¹è¯' },
        { value: 'skills', label: 'ğŸ”§ ç®¡ç†æŠ€èƒ½' },
        { value: 'memory', label: 'ğŸ§  æŸ¥çœ‹è®°å¿†' },
        { value: 'exit', label: 'ğŸ‘‹ é€€å‡º' }
      ]
    });
    
    if (action === 'exit') break;
    // ...
  }
}
```

**ä¼˜å…ˆçº§ï¼š** â­â­â­
**å·¥ä½œé‡ï¼š** å°ï¼ˆ1å¤©ï¼‰

---

## å…­ã€å®‰å…¨ä¸éš”ç¦»æ”¹è¿›

### 6.1 æŠ€èƒ½æ²™ç®±ï¼ˆå€Ÿé‰´ NanoClawï¼‰

**ç°çŠ¶é—®é¢˜ï¼š**
- å½“å‰æŠ€èƒ½ä½¿ç”¨vmæ¨¡å—æ‰§è¡Œï¼Œä½†ä»å¯è®¿é—®Node.jsæ ¸å¿ƒæ¨¡å—
- æ— æ–‡ä»¶ç³»ç»Ÿéš”ç¦»

**æ”¹è¿›æ–¹æ¡ˆï¼š**
```javascript
// lib/skill-sandbox.js
class SkillSandbox {
  constructor(skillId, allowedPaths = []) {
    this.skillId = skillId;
    this.allowedPaths = allowedPaths;
    
    // åˆ›å»ºå—é™çš„require
    this.safeRequire = this.createSafeRequire();
  }
  
  createSafeRequire() {
    const whitelist = new Set(['url', 'querystring', 'crypto', 'util']);
    
    return (moduleName) => {
      if (whitelist.has(moduleName)) {
        return require(moduleName);
      }
      
      // ç¦æ­¢æ–‡ä»¶ç³»ç»Ÿè®¿é—®
      if (['fs', 'path'].includes(moduleName)) {
        return this.createMockFs();
      }
      
      throw new Error(`Module '${moduleName}' is not allowed`);
    };
  }
  
  createMockFs() {
    return {
      readFileSync: (filePath) => {
        // åªå…è®¸è®¿é—®æŠ€èƒ½ç›®å½•ä¸‹çš„æ–‡ä»¶
        if (!filePath.startsWith(this.skillBasePath)) {
          throw new Error('Access denied');
        }
        return fs.readFileSync(filePath);
      }
    };
  }
  
  execute(code) {
    const context = vm.createContext({
      require: this.safeRequire,
      console: this.createSafeConsole(),
      Buffer,
      // ...å…¶ä»–å®‰å…¨çš„å…¨å±€å˜é‡
    });
    
    vm.runInContext(code, context, { timeout: 5000 });
    return context.module.exports;
  }
}
```

**ä¼˜å…ˆçº§ï¼š** â­â­â­â­
**å·¥ä½œé‡ï¼š** ä¸­ç­‰ï¼ˆ2å¤©ï¼‰

---

## ä¸ƒã€å®æ–½è·¯çº¿å›¾

### ç¬¬ä¸€é˜¶æ®µï¼šæ ¸å¿ƒèƒ½åŠ›æå‡ï¼ˆ2å‘¨ï¼‰

| ä»»åŠ¡ | ä¼˜å…ˆçº§ | å·¥ä½œé‡ | è´Ÿè´£äºº |
|------|--------|--------|--------|
| å‘é‡è®°å¿†ç³»ç»Ÿ | â­â­â­â­â­ | 3å¤© | - |
| TOMLå£°æ˜å¼æŠ€èƒ½ | â­â­â­â­â­ | 3å¤© | - |
| MCPé€‚é…å™¨ | â­â­â­â­â­ | 2å¤© | - |
| WeChaté€šé“é›†æˆ | â­â­â­â­â­ | 3å¤© | - |

### ç¬¬äºŒé˜¶æ®µï¼šç”Ÿæ€å®Œå–„ï¼ˆ1å‘¨ï¼‰

| ä»»åŠ¡ | ä¼˜å…ˆçº§ | å·¥ä½œé‡ |
|------|--------|--------|
| æŠ€èƒ½å¸‚åœºåŒæ­¥ | â­â­â­â­ | 2å¤© |
| æ··åˆæœç´¢ä¼˜åŒ– | â­â­â­â­ | 1å¤© |
| CLIäº¤äº’ç¾åŒ– | â­â­â­ | 1å¤© |

### ç¬¬ä¸‰é˜¶æ®µï¼šå®‰å…¨åŠ å›ºï¼ˆ1å‘¨ï¼‰

| ä»»åŠ¡ | ä¼˜å…ˆçº§ | å·¥ä½œé‡ |
|------|--------|--------|
| æŠ€èƒ½æ²™ç®± | â­â­â­â­ | 2å¤© |
| æ›´å¤šé€šé“ï¼ˆTelegram/Slackï¼‰ | â­â­â­â­ | 3å¤© |

---

## å…«ã€å‚è€ƒä»£ç ç‰‡æ®µ

### 8.1 è½»é‡çº§EmbeddingæœåŠ¡

```python
# embedding-service/main.py (FastAPI)
from fastapi import FastAPI
from sentence_transformers import SentenceTransformer

app = FastAPI()
model = SentenceTransformer('BAAI/bge-small-zh-v1.5')  # ä¸­æ–‡ä¼˜åŒ–ï¼Œä»…100MB

@app.post("/embed")
async def embed(texts: list[str]):
    embeddings = model.encode(texts, normalize_embeddings=True)
    return {"embeddings": embeddings.tolist()}
```

### 8.2 ä½™å¼¦ç›¸ä¼¼åº¦è®¡ç®—ï¼ˆSQLï¼‰

```sql
-- MySQL 8.0+ æ”¯æŒå‘é‡å‡½æ•°
CREATE FUNCTION cosine_similarity(a JSON, b JSON) 
RETURNS FLOAT DETERMINISTIC
BEGIN
  DECLARE dot_product FLOAT DEFAULT 0;
  DECLARE norm_a FLOAT DEFAULT 0;
  DECLARE norm_b FLOAT DEFAULT 0;
  DECLARE i INT DEFAULT 0;
  DECLARE dim INT;
  
  SET dim = JSON_LENGTH(a);
  
  WHILE i < dim DO
    SET dot_product = dot_product + 
      JSON_EXTRACT(a, CONCAT('$[', i, ']')) * 
      JSON_EXTRACT(b, CONCAT('$[', i, ']'));
    SET norm_a = norm_a + POW(JSON_EXTRACT(a, CONCAT('$[', i, ']')), 2);
    SET norm_b = norm_b + POW(JSON_EXTRACT(b, CONCAT('$[', i, ']')), 2);
    SET i = i + 1;
  END WHILE;
  
  RETURN dot_product / (SQRT(norm_a) * SQRT(norm_b));
END;
```

---

## ä¹ã€æ€»ç»“

**æœ€é«˜ä¼˜å…ˆçº§æ”¹è¿›é¡¹ï¼š**

1. **å‘é‡è®°å¿†ç³»ç»Ÿ** - è§£å†³å½“å‰TopicåŒ¹é…çš„ç—›ç‚¹
2. **TOMLå£°æ˜å¼æŠ€èƒ½** - é™ä½æŠ€èƒ½å¼€å‘é—¨æ§›
3. **MCPé€‚é…å™¨** - ç¬é—´æ‰©å±•å·¥å…·èƒ½åŠ›
4. **WeChaté€šé“** - æ‰©å¤§ç”¨æˆ·è§¦è¾¾

**é¢„æœŸæ”¶ç›Šï¼š**
- è®°å¿†æ£€ç´¢å‡†ç¡®ç‡ +50%
- æŠ€èƒ½å¼€å‘æ•ˆç‡ +200%
- å¯ç”¨å·¥å…·æ•°é‡ +900
- ç”¨æˆ·è§¦è¾¾æ¸ é“ +3

---

*æŠ¥å‘Šç”Ÿæˆæ—¶é—´ï¼š2026-02-16*
*å‚è€ƒé¡¹ç›®ç‰ˆæœ¬ï¼šNanoClaw (main)ã€OpenClaw (main)ã€PicoClaw (main)ã€ZeroClaw (main)*
